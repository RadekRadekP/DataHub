@* GenericFilter.razor *@
@namespace RPK_BlazorApp.Components.Shared // Add this line
@using Microsoft.AspNetCore.Components
@using RPK_BlazorApp.Models.DataGrid
@using RPK_BlazorApp.Models.UI
@using Microsoft.FluentUI.AspNetCore.Components

@typeparam TItem where TItem : class

<div class="app-filter-bar">
    @foreach (var filterRow in FilterRows)
    {
        <div class="filter-group">
            <FluentSelect TOption="string" Label="Filtr" Value="@filterRow.SelectedColumnName" @onchange="@((args) => OnColumnChanged(filterRow, args.Value?.ToString()))">
                <FluentOption Value="">-- Select Column --</FluentOption>
                @foreach (var col in FilterableColumns)
                {
                    <FluentOption Value="@col.FieldName">@col.DisplayName</FluentOption>
                }
            </FluentSelect>

            @if (filterRow.SelectedColumn != null)
            {
                <FluentSelect TOption="string" @bind-Value="filterRow.SelectedOperatorString">
                    @foreach (var op in GetOperatorsForType(filterRow.SelectedColumn.DataType))
                    {
                        <FluentOption Value="@op.ToString()">@op.GetDescription()</FluentOption>
                    }
                </FluentSelect>

                @if (filterRow.SelectedOperator == FilterOperator.In || filterRow.SelectedOperator == FilterOperator.NotIn)
                {
                    <FluentTextField @bind-Value="filterRow.FilterValue" Placeholder="Comma separated values" />
                }
                else if (filterRow.SelectedColumn.DataType == typeof(DateTime))
                {
                    <FluentDatePicker Value="filterRow.FilterDateValue" ValueChanged="@((DateTime? value) => filterRow.FilterDateValue = value)" />
                }
                else if (filterRow.SelectedColumn.DataType == typeof(bool))
                {
                    <FluentSelect TOption="string" @bind-Value="filterRow.FilterValue">
                        <FluentOption Value="">-- Select --</FluentOption>
                        <FluentOption Value="True">True</FluentOption>
                        <FluentOption Value="False">False</FluentOption>
                    </FluentSelect>
                }
                else
                {
                    <FluentTextField @bind-Value="filterRow.FilterValue" Placeholder="Enter value" />
                }
            }
            <FluentButton Appearance="@Appearance.Outline" @onclick="() => RemoveFilterRow(filterRow)">Remove</FluentButton>
        </div>
    }
    <div class="action-buttons">
        <FluentButton Appearance="@Appearance.Neutral" @onclick="AddFilterRow">Add Filter</FluentButton>
        <FluentButton Appearance="@Appearance.Accent" @onclick="ApplyAllFilters">Apply All Filters</FluentButton>
        <FluentButton Appearance="@Appearance.Neutral" @onclick="ClearAllFilters">Clear All Filters</FluentButton>
    </div>
</div>

@code {
    [Parameter] public List<ColumnDefinition<TItem>> ColumnDefinitions { get; set; } = new();
    [Parameter] public EventCallback<List<FilterCriterion>> OnFilterApplied { get; set; }

    private List<ColumnDefinition<TItem>> FilterableColumns => ColumnDefinitions.Where(c => c.IsFilterable).ToList();

    private List<FilterRowState> FilterRows { get; set; } = new();

    [Inject] private ILogger<GenericFilter<TItem>> Logger { get; set; } = default!;

    protected override void OnInitialized()
    {
        AddFilterRow(); // Start with one empty filter row
    }

    private void AddFilterRow()
    {
        FilterRows.Add(new FilterRowState());
    }

    private void RemoveFilterRow(FilterRowState rowToRemove)
    {
        FilterRows.Remove(rowToRemove);
        if (!FilterRows.Any())
        {
            AddFilterRow(); // Ensure at least one row remains
        }
        // Re-apply filters after removal
        _ = ApplyAllFilters();
    }

    private void OnColumnChanged(FilterRowState filterRow, string? newColumnName)
    {
        filterRow.SelectedColumnName = newColumnName ?? string.Empty; // Update the bound property
        Console.WriteLine($"OnColumnChanged triggered for column: {filterRow.SelectedColumnName}");
        Logger.LogInformation("OnColumnChanged: SelectedColumnName before change: {SelectedColumnName}", filterRow.SelectedColumnName);
        filterRow.SelectedColumn = FilterableColumns.FirstOrDefault(c => {
            Logger.LogInformation($"Comparing: {c.FieldName} == {filterRow.SelectedColumnName} (case-insensitive)");
            return c.FieldName.Equals(filterRow.SelectedColumnName, StringComparison.OrdinalIgnoreCase);
        });
        Logger.LogInformation("OnColumnChanged: SelectedColumn after change: {SelectedColumnName}, DataType: {DataType}", filterRow.SelectedColumn?.FieldName, filterRow.SelectedColumn?.DataType);
        // Reset operator and value when column changes
        filterRow.SelectedOperatorString = FilterOperator.Equals.ToString();
        filterRow.FilterValue = string.Empty;
        filterRow.FilterDateValue = null;
        Logger.LogInformation("OnColumnChanged: SelectedOperatorString after reset: {SelectedOperatorString}", filterRow.SelectedOperatorString);
        StateHasChanged();
    }

    private IEnumerable<FilterOperator> GetOperatorsForType(Type? dataType)
    {
        if (dataType == typeof(string))
        {
            return new[] { FilterOperator.Equals, FilterOperator.Contains, FilterOperator.StartsWith, FilterOperator.EndsWith, FilterOperator.NotEquals, FilterOperator.In, FilterOperator.NotIn };
        }
        else if (dataType == typeof(int) || dataType == typeof(double) || dataType == typeof(decimal) || dataType == typeof(float))
        {
            return new[] { FilterOperator.Equals, FilterOperator.GreaterThan, FilterOperator.LessThan, FilterOperator.GreaterThanOrEqual, FilterOperator.LessThanOrEqual, FilterOperator.NotEquals, FilterOperator.In, FilterOperator.NotIn };
        }
        else if (dataType == typeof(DateTime))
        {
            return new[] { FilterOperator.Equals, FilterOperator.GreaterThan, FilterOperator.LessThan, FilterOperator.GreaterThanOrEqual, FilterOperator.LessThanOrEqual, FilterOperator.NotEquals };
        }
        else if (dataType == typeof(bool))
        {
            return new[] { FilterOperator.Equals, FilterOperator.Equals, FilterOperator.NotEquals };
        }
        return Enumerable.Empty<FilterOperator>();
    }

    private async Task ApplyAllFilters()
    {
        var appliedCriteria = new List<FilterCriterion>();
        foreach (var row in FilterRows)
        {
            // Set the SelectedColumn property for the FilterRowState based on the selected name
            row.SelectedColumn = FilterableColumns.FirstOrDefault(c => c.FieldName == row.SelectedColumnName);

            if (row.SelectedColumn != null && (!string.IsNullOrWhiteSpace(row.FilterValue) || row.FilterDateValue.HasValue))
            {
                object? valueToFilter = null;
                if (row.SelectedColumn.DataType == typeof(DateTime))
                {
                    valueToFilter = row.FilterDateValue;
                }
                else
                {
                    valueToFilter = row.FilterValue;
                }

                if (valueToFilter != null)
                {
                    if (row.SelectedOperator == FilterOperator.In || row.SelectedOperator == FilterOperator.NotIn)
                    {
                        var values = row.FilterValue.Split(',').Select(v => v.Trim()).Where(v => !string.IsNullOrWhiteSpace(v)).ToList();
                        if (values.Any())
                        {
                            appliedCriteria.Add(new FilterCriterion
                            {
                                FieldName = row.SelectedColumn.FieldName,
                                Operator = row.SelectedOperator,
                                Values = values
                            });
                        }
                    }
                    else
                    {
                        appliedCriteria.Add(new FilterCriterion
                        {
                            FieldName = row.SelectedColumn.FieldName,
                            Operator = row.SelectedOperator,
                            Value = valueToFilter
                        });
                    }
                }
            }
        }
        await OnFilterApplied.InvokeAsync(appliedCriteria);
    }

    private async Task ClearAllFilters()
    {
        FilterRows.Clear();
        AddFilterRow(); // Start with one empty filter row
        await OnFilterApplied.InvokeAsync(new List<FilterCriterion>());
    }

    // Helper class to hold state for each filter row
    private class FilterRowState
    {
        public string SelectedColumnName { get; set; } = string.Empty;
        public ColumnDefinition<TItem>? SelectedColumn { get; set; } // Will be set by parent component
        public string SelectedOperatorString { get; set; } = FilterOperator.Equals.ToString();
        public FilterOperator SelectedOperator => Enum.Parse<FilterOperator>(SelectedOperatorString);
        public string FilterValue { get; set; } = string.Empty;
        public DateTime? FilterDateValue { get; set; }
    }
}