@* GenericDataView.razor - Enhanced UI Version *@
@namespace DataHub.Core.Components.Shared
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using DataHub.Core.Models.DataGrid
@using DataHub.Core.Models.UI
@using DataHub.Core.Services
@using DataHub.Core.Models.Metadata
@using Microsoft.FluentUI.AspNetCore.Components
@using Microsoft.FluentUI.AspNetCore.Components.DataGrid
@using static Microsoft.FluentUI.AspNetCore.Components.Appearance
@using Microsoft.FluentUI.AspNetCore.Components.Icons
@using Microsoft.Extensions.Logging
@using System.Linq.Expressions
@using System.Reflection

@typeparam TItem where TItem : class

<div @ref="_container" class="generic-data-view-container" @onkeydown="HandleGridKeyDown" @onkeydown:preventDefault="_preventDefault" tabindex="0">
    
    <FluentCard Class="data-grid-card">
        @* Toolbar *@
        <FluentStack Orientation="Orientation.Vertical" Class="grid-toolbar-section mb-3">
            <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="HorizontalAlignment.Start" Class="toolbar-main">
                @* Left side - Title and record count *@
                <FluentStack Orientation="Orientation.Horizontal" HorizontalGap="12" Class="toolbar-left">
                    @if (!string.IsNullOrEmpty(GridTitle))
                    {
                        <h3 class="grid-title">@GridTitle</h3>
                    }
                    <FluentBadge Appearance="Appearance.Neutral" Class="record-badge">
                        @_paginationState.TotalItemCount records
                    </FluentBadge>
                </FluentStack>

                @* Right side - Actions *@
                <FluentStack Orientation="Orientation.Horizontal" HorizontalGap="8" Class="toolbar-right">
                    <FluentButton Appearance="Appearance.Neutral" OnClick="RefreshGrid" Title="Refresh data">
                        üîÑ Refresh
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Accent" OnClick="HandleExportToExcel" Title="Export to Excel">
                        üìä Export
                    </FluentButton>
                </FluentStack>
            </FluentStack>

            @* Bulk actions toolbar (shown when items selected) *@
            @if (ShowCheckboxes && SelectedItems.Count > 0)
            {
                <FluentStack Orientation="Orientation.Horizontal" HorizontalGap="8" Class="bulk-actions-bar">
                    <FluentBadge Appearance="Appearance.Accent" Class="selection-badge">
                        @SelectedItems.Count selected
                    </FluentBadge>
                    <FluentButton Appearance="Appearance.Neutral" OnClick="ClearSelection" Title="Clear selection">
                        ‚úñÔ∏è Clear
                    </FluentButton>
                    @if (BulkActionsTemplate != null)
                    {
                        @BulkActionsTemplate
                    }
                </FluentStack>
            }
        </FluentStack>

        @* Data Grid *@
        <div class="grid-container">
            <FluentDataGrid @ref="fluentDataGrid" ItemsProvider="@ProvideItems" ResizableColumns="true" TGridItem="TItem"
                            GridTemplateColumns="@GridTemplateColumns" Pagination="@_paginationState" Key="@_refreshKey" @bind-CurrentItem="_currentlyFocusedItem"
                            Class="enhanced-data-grid">
                @if (ShowCheckboxes)
                {
                    <TemplateColumn Class="checkbox-column">
                        <HeaderCellTitleTemplate>
                            <FluentCheckbox Label="Select all" Value="_areAllOnPageSelected" ValueChanged="OnSelectAllChanged" />
                        </HeaderCellTitleTemplate>
                        <ChildContent Context="item">
                            <FluentCheckbox Value="@SelectedItems.Contains(item)" ValueChanged="(newValue) => OnItemCheckedChanged(newValue, item)" />
                        </ChildContent>
                    </TemplateColumn>
                }

                @foreach (var column in ColumnDefinitions)
                {
                    <TemplateColumn Sortable="false">
                        <ColumnOptions>
                            <FluentCheckbox Label="Visible" @bind-Value="@column.IsVisible" />
                        </ColumnOptions>
                        <HeaderCellTitleTemplate>
                            <span class="column-header">
                                @column.DisplayName
                            </span>
                        </HeaderCellTitleTemplate>
                        <ChildContent Context="item">
                            @if (column.GetValue != null)
                            {
                                <span class="cell-content">@(column.GetValue.Compile().Invoke(item)?.ToString())</span>
                            }
                        </ChildContent>
                    </TemplateColumn>
                }

                @if (ActionColumnTemplate != null)
                {
                    <TemplateColumn Title="Actions" Align="Align.End" Class="action-column">
                        <ChildContent Context="item">
                            @ActionColumnTemplate(item)
                        </ChildContent>
                    </TemplateColumn>
                }
            </FluentDataGrid>
        </div>

        @* Enhanced Pagination Bar *@
        <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="HorizontalAlignment.Start" Class="pagination-bar mt-3">
            @* Record range display *@
            <div class="record-range">
                @{
                    var startRecord = (_paginationState.CurrentPageIndex * _paginationState.ItemsPerPage) + 1;
                    var endRecord = Math.Min((_paginationState.CurrentPageIndex + 1) * _paginationState.ItemsPerPage, _paginationState.TotalItemCount ?? 0);
                }
                Showing @startRecord - @endRecord of @(_paginationState.TotalItemCount ?? 0)
            </div>

            @* Pagination control *@
            @* Pagination control - Manual implementation to avoid FluentPaginator DivideByZero crash *@
            <FluentStack Orientation="Orientation.Horizontal" HorizontalGap="4" VerticalAlignment="VerticalAlignment.Center">
                <FluentButton Appearance="Appearance.Stealth" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ChevronLeft())"
                              OnClick="@(() => _paginationState.SetCurrentPageIndexAsync(_paginationState.CurrentPageIndex - 1))"
                              Disabled="@(_paginationState.CurrentPageIndex == 0)"
                              Title="Previous page" />
                
                <span class="pagination-page-info">
                    Page @(_paginationState.CurrentPageIndex + 1)
                    @if (_paginationState.TotalItemCount.HasValue)
                    {
                        @: of @((_paginationState.TotalItemCount.Value + _paginationState.ItemsPerPage - 1) / Math.Max(1, _paginationState.ItemsPerPage))
                    }
                </span>

                <FluentButton Appearance="Appearance.Stealth" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ChevronRight())"
                              OnClick="@(() => _paginationState.SetCurrentPageIndexAsync(_paginationState.CurrentPageIndex + 1))"
                              Disabled="@(!_paginationState.TotalItemCount.HasValue || (_paginationState.CurrentPageIndex + 1) * _paginationState.ItemsPerPage >= _paginationState.TotalItemCount)"
                              Title="Next page" />
            </FluentStack>

            @* Page size selector *@
            <FluentStack Orientation="Orientation.Horizontal" HorizontalGap="8" Class="page-size-selector">
                <span class="page-size-label">Per page:</span>
                <FluentSelect Items="@_pageSizeOptions" @bind-SelectedOption="@_selectedPageSize" @bind-SelectedOption:after="OnPageSizeChangedSimple">
                    <OptionTemplate>@context</OptionTemplate>
                </FluentSelect>
            </FluentStack>
        </FluentStack>
    </FluentCard>
</div>

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    [Parameter] public Func<DataRequestBase, Task<DataResult<TItem>>> DataProvider { get; set; } = default!;
    [Parameter] public Func<DataRequestBase, Task<Stream>> ExportFunction { get; set; } = default!;
    [Parameter] public int PageSize { get; set; } = 10;
    [Parameter] public List<ColumnDefinition<TItem>> ColumnDefinitions { get; set; } = new();
    [Parameter] public List<FilterCriterion> CurrentFilters { get; set; } = new();
    [Parameter] public string ExportFileName { get; set; } = "exceldata";
    [Parameter] public bool ShowCheckboxes { get; set; } = false;
    [Parameter] public RenderFragment<TItem>? ActionColumnTemplate { get; set; }
    [Parameter] public RenderFragment? BulkActionsTemplate { get; set; }
    [Parameter] public HashSet<TItem> SelectedItems { get; set; } = new();
    [Parameter] public EventCallback<HashSet<TItem>> SelectedItemsChanged { get; set; }
    [Parameter] public string GridTitle { get; set; } = "";

    [Inject] private ILogger<GenericDataView<TItem>> Logger { get; set; } = default!;
    [Inject] private IJSRuntime JSRuntime { get; set; } = default!;
    [Inject] private IMetadataService MetadataService { get; set; } = default!;

    private ElementReference _container;
    private PaginationState _paginationState = new PaginationState { ItemsPerPage = 10 };
    private int _refreshKey = 0;
    private bool _preventDefault = false;
    private TItem? _currentlyFocusedItem;
    private FluentDataGrid<TItem> fluentDataGrid = default!;
    private bool _areAllOnPageSelected = false;
    private List<TItem> _currentPageItems = new();

    private int[] _pageSizeOptions = new[] { 10, 25, 50, 100 };
    private int _selectedPageSize = 10;

    [Parameter]
    public string GridTemplateColumns { get; set; } = "";

    [Parameter]
    public int? MetaEntityId { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (PageSize <= 0) PageSize = 10;
        _paginationState.ItemsPerPage = PageSize;
        _selectedPageSize = PageSize;

        // Auto-generate columns from SysView if MetaEntityId is provided
        if (MetaEntityId.HasValue && (ColumnDefinitions == null || !ColumnDefinitions.Any()))
        {
            await LoadColumnsFromMetadata();
        }
    }

    protected override void OnParametersSet()
    {
        if (PageSize <= 0) PageSize = 10;
        if (_paginationState.ItemsPerPage != PageSize && _paginationState.ItemsPerPage != _selectedPageSize)
        {
            _paginationState.ItemsPerPage = PageSize;
            _selectedPageSize = PageSize;
        }
    }

    private async Task LoadColumnsFromMetadata()
    {
        try
        {
            var view = await MetadataService.GetDefaultViewAsync(MetaEntityId.Value);
            if (view != null && view.Fields.Any())
            {
                var newCols = new List<ColumnDefinition<TItem>>();
                foreach (var field in view.Fields.OrderBy(f => f.Order))
                {
                    if (field.MetaField == null) continue;

                    var propName = field.MetaField.FieldName;
                    var expr = CreatePropertyAccessor(propName);
                    
                    if (expr != null)
                    {
                        newCols.Add(new ColumnDefinition<TItem>
                        {
                            FieldName = propName,
                            DisplayName = field.CustomLabel ?? field.MetaField.DisplayName,
                            IsVisible = field.IsVisible,
                            IsSortable = true, // Default to true for now
                            IsFilterable = true,
                            GetValue = expr,
                            DataType = typeof(TItem).GetProperty(propName)?.PropertyType
                        });
                    }
                }

                if (newCols.Any())
                {
                    ColumnDefinitions = newCols;
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load columns from metadata for Entity {id}", MetaEntityId);
        }
    }

    private Expression<Func<TItem, object>>? CreatePropertyAccessor(string propertyName)
    {
        try
        {
            var param = Expression.Parameter(typeof(TItem), "x");
            var propertyInfo = typeof(TItem).GetProperty(propertyName);
            
            if (propertyInfo == null) return null;

            var property = Expression.Property(param, propertyInfo);
            var conversion = Expression.Convert(property, typeof(object));
            return Expression.Lambda<Func<TItem, object>>(conversion, param);
        }
        catch
        {
            return null;
        }
    }

    private async Task OnPageSizeChangedSimple()
    {
        _paginationState.ItemsPerPage = _selectedPageSize;
        await RefreshGrid();
    }

    public async Task RefreshDataAsync()
    {
        await RefreshGrid();
    }

    private async Task RefreshGrid()
    {
        _refreshKey++;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ClearSelection()
    {
        SelectedItems.Clear();
        _areAllOnPageSelected = false;
        await SelectedItemsChanged.InvokeAsync(SelectedItems);
    }

    private async ValueTask<GridItemsProviderResult<TItem>> ProvideItems(GridItemsProviderRequest<TItem> request)
    {
        var visibleCols = ColumnDefinitions.Where(c => c.IsVisible).Select(c => c.FieldName).ToList();
            var reqCount = request.Count.HasValue && request.Count.Value > 0 ? request.Count.Value : PageSize;
            var dataRequest = new ServerDataRequest
            {
                Page = (request.StartIndex / reqCount) + 1,
                PageSize = reqCount,
                Criteria = CurrentFilters
            };

        var result = await DataProvider(dataRequest);
        _currentPageItems = result.Data.ToList();
        // TotalItemCount is read-only, FluentUI will get it from GridItemsProviderResult

        _areAllOnPageSelected = _currentPageItems.Count > 0 && _currentPageItems.All(item => SelectedItems.Contains(item));

        return GridItemsProviderResult.From<TItem>(items: result.Data.ToList(), totalItemCount: result.TotalCount);
    }

    private async Task HandleExportToExcel()
    {
        try
        {
            var visibleCols = ColumnDefinitions.Where(c => c.IsVisible).Select(c => c.FieldName).ToList();
            var exportRequest = new ServerDataRequest
            {
                Page = 1,
                PageSize = int.MaxValue,
                GetAll = true,
                Criteria = CurrentFilters
            };

            var stream = await ExportFunction(exportRequest);
            var fileName = $"{ExportFileName}_{DateTime.Now:yyyyMMdd_HHmmss}.xlsx";

            using var streamRef = new DotNetStreamReference(stream: stream);
            await JSRuntime.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting to Excel");
        }
    }

    private async Task OnSelectAllChanged(bool newValue)
    {
        _areAllOnPageSelected = newValue;
        if (newValue)
        {
            foreach (var item in _currentPageItems)
            {
                SelectedItems.Add(item);
            }
        }
        else
        {
            foreach (var item in _currentPageItems)
            {
                SelectedItems.Remove(item);
            }
        }
        await SelectedItemsChanged.InvokeAsync(SelectedItems);
    }

    private async Task OnItemCheckedChanged(bool isChecked, TItem item)
    {
        if (isChecked)
        {
            SelectedItems.Add(item);
        }
        else
        {
            SelectedItems.Remove(item);
        }
        _areAllOnPageSelected = _currentPageItems.Count > 0 && _currentPageItems.All(i => SelectedItems.Contains(i));
        await SelectedItemsChanged.InvokeAsync(SelectedItems);
    }

    private void HandleGridKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "PageDown" || e.Key == "PageUp")
        {
            _preventDefault = true;
        }
        else
        {
            _preventDefault = false;
        }
    }
}
